# tensor_impl.pyi
from typing import Any, Callable, Iterable, List, Optional, Sequence, Tuple, overload, Union

dtype = Any
Storage = Any
shape_t = List[int]
stride_t = List[int]
slice_t = Any
veci = List[int]

class TensorBase:
    def __init__(self, value: dtype = ..., /): ...
    def __init__(self, shape: shape_t, value: dtype, /): ...
    def __init__(self, shape: shape_t, generator: Callable[[], dtype], /): ...
    def __init__(self, shape: shape_t, data: List[dtype], /): ...
    def __init__(self, shape: shape_t, stride: stride_t, offset: int, storage: Storage, /): ...
    def __init__(self, other: "TensorBase", /): ...
    def __init__(self, data: list, /): ...

    # repr
    def __repr__(self) -> str: ...

    # Properties
    @property
    def shape(self) -> shape_t: ...

    # Graderlib utils
    def data_at(self, index: int) -> dtype: ...
    def change_data_at(self, index: int, value: dtype) -> None: ...
    def tolist(self) -> Any: ...

    # Copy/clone
    def __copy__(self) -> "TensorBase": ...
    def __deepcopy__(self, memo: Any = ...) -> "TensorBase": ...
    def clone(self) -> "TensorBase": ...

    # Item
    def item(self) -> dtype: ...

    # Utils
    def dim(self) -> int: ...
    def size(self) -> shape_t: ...
    def size(self, dim: int) -> int: ...
    def is_contiguous(self) -> bool: ...
    def contiguous(self) -> "TensorBase": ...
    def copy_(self, other: "TensorBase") -> None: ...
    def scatter_(self, dim: int, index: "TensorBase", src: "TensorBase") -> None: ...

    # Indexing
    def __getitem__(self, index: Union[int, veci, slice, Tuple, Any]) -> "TensorBase": ...
    def __setitem__(self, index: Union[int, veci, slice, Tuple, Any], value: Union[float, "TensorBase"]) -> None: ...

    # Unary/binary operators
    def __neg__(self) -> "TensorBase": ...
    def __add__(self, other: Union["TensorBase", dtype]) -> "TensorBase": ...
    def __radd__(self, other: dtype) -> "TensorBase": ...
    def __sub__(self, other: Union["TensorBase", dtype]) -> "TensorBase": ...
    def __rsub__(self, other: dtype) -> "TensorBase": ...
    def __mul__(self, other: Union["TensorBase", dtype]) -> "TensorBase": ...
    def __rmul__(self, other: dtype) -> "TensorBase": ...
    def __truediv__(self, other: Union["TensorBase", dtype]) -> "TensorBase": ...
    def __rtruediv__(self, other: dtype) -> "TensorBase": ...
    def __abs__(self) -> "TensorBase": ...

    def sign(self) -> "TensorBase": ...
    def abs(self) -> "TensorBase": ...
    def sin(self) -> "TensorBase": ...
    def cos(self) -> "TensorBase": ...
    def tanh(self) -> "TensorBase": ...
    def clamp(self, min: dtype, max: dtype) -> "TensorBase": ...
    def log(self) -> "TensorBase": ...
    def exp(self) -> "TensorBase": ...
    def pow(self, exponent: dtype) -> "TensorBase": ...
    def sqrt(self) -> "TensorBase": ...

    # Matrix ops
    def matmul(self, other: "TensorBase") -> "TensorBase": ...
    def __matmul__(self, other: "TensorBase") -> "TensorBase": ...

    # Reduction
    def sum(self, dim: int, keepdims: bool = ...) -> "TensorBase": ...
    def max(self, dim: int, keepdims: bool = ...) -> Tuple["TensorBase", "TensorBase"]: ...
    def softmax(self, dim: int) -> "TensorBase": ...

    # Shape
    def reshape(self, *shape: int, copy: bool = ...) -> "TensorBase": ...
    def view(self, *shape: int) -> "TensorBase": ...
    def transpose(self, dim0: int, dim1: int) -> "TensorBase": ...
    @property
    def T(self) -> "TensorBase": ...

    def permute(self, dims: Sequence[int]) -> "TensorBase": ...
    def narrow(self, dim: int, start: int, length: int, copy: bool = ...) -> "TensorBase": ...
    def chunk(self, chunks: int, dim: int) -> List["TensorBase"]: ...
    def split(self, split_size: int, dim: int = ...) -> List["TensorBase"]: ...
    def squeeze(self, dim: int = ...) -> "TensorBase": ...
    def unsqueeze(self, dim: int = ...) -> "TensorBase": ...
    def broadcast_to(self, shape: Sequence[int]) -> "TensorBase": ...
    def broadcast(self, *tensors: "TensorBase") -> List["TensorBase"]: ...
    
    # Week3
    def mean(self, dim: int, keepdims: bool) -> "TensorBase": ...
    def var(self, dim: int, keepdims: bool, unbiased: bool) -> "TensorBase": ...
    

# Other methods called with "cp."
def numel(self: TensorBase) -> int: ...
def ones(shape: shape_t) -> TensorBase: ...
def ones_like(self: TensorBase) -> TensorBase: ...
def zeros(shape: shape_t) -> TensorBase: ...
def zeros_like(self: TensorBase) -> TensorBase: ...
def randn(shape: shape_t) -> TensorBase: ...
def randn_like(self: TensorBase) -> TensorBase: ...
def empty(shape: shape_t) -> TensorBase: ...
def empty_like(self: TensorBase) -> TensorBase: ...
def arange(start: dtype, end: dtype, step: int = ...) -> TensorBase: ...
def range(start: dtype, end: dtype, step: int = ...) -> TensorBase: ...
def linspace(start: dtype, end: dtype, num_steps: int) -> TensorBase: ...
def stack(tensors: List[TensorBase], dim: int = ...) -> TensorBase: ...
def cat(tensors: List[TensorBase], dim: int = ...) -> TensorBase: ...
def squeeze(self: TensorBase, dim: int = ...) -> TensorBase: ...
def unsqueeze(self: TensorBase, dim: int = ...) -> TensorBase: ...
def broadcast_to(self: TensorBase, shape: shape_t) -> TensorBase: ...
def broadcast_tensors(lhs: TensorBase, rhs: TensorBase) -> List[TensorBase]: ...
def broadcast_tensors(tensors: List[TensorBase]) -> List[TensorBase]: ...
def to_singleton_tensor(value: dtype, dim: int) -> TensorBase: ...
def dot(a: TensorBase, b: TensorBase) -> TensorBase: ...

#  Comparison operators
def __eq__(a: TensorBase, b: TensorBase) -> TensorBase: ...
def __ne__(a: TensorBase, b: TensorBase) -> TensorBase: ...
def __lt__(a: TensorBase, b: TensorBase) -> TensorBase: ...
def __le__(a: TensorBase, b: TensorBase) -> TensorBase: ...
def __gt__(a: TensorBase, b: TensorBase) -> TensorBase: ...
def __ge__(a: TensorBase, b: TensorBase) -> TensorBase: ...